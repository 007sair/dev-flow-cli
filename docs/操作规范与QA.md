# 🚀 团队 Git 开发工作流：从“混乱”到“原子化”的演进

## 1. 为什么会有这个开发流程工具？

在过去，我们团队习惯使用传统的 `git merge`。这种方式虽然简单，但随着协作人数增加，暴露了两个核心痛点：

*   **“小耳朵”节点泛滥**：公共分支上充斥着大量 `Merge branch '...' into feat/xxx` 这样的合并记录，淹没了真正的业务改动。
*   **历史链路交织**：提交记录像乱麻一样，导致 Code Review 时找不到重点，线上出问题想回滚某个功能时，根本分不清哪些提交属于哪个功能。

**新工具 `flow` 的目标：**
通过 **rebase（变基）** 代替 **merge**。
*   **rebase 的意义**：它会将你的开发记录“嫁接”在公共分支的最新节点之后，从而消灭合并节点，保持公共分支是一条笔直、清晰的**直线**。
*   **原子提交**：将你本地的多次碎片化提交（fix、test、temp）合并为一个有意义的“原子提交”，让历史像书一样好读。

---

## 2. `flow` 工具的操作流程

开发者只需在终端执行 `flow`，工具将自动化完成以下高阶操作：

1.  **自动同步（rebase）**：工具执行 `fetch` 和 `rebase`。
    - 它会将你的本地修改“漂移”到公共分支的最前端。若有冲突，在此处手动解决。
2.  **原子化打包（Local Squash）**：若检测到多个 Commit，工具提示输入最终提交信息。
    - 它利用 `Soft Reset` 魔法，在**你的本地分支**先完成压缩，生成一个全新的原子提交 ID。
3.  **快进合并（fast-forward）**：工具切换到公共分支，由于你已经做了 rebase 和本地压缩，此时公共分支只需“指针右移”即可合入。
4.  **无感归位**：工具切回个人分支。
    - **最强优势**：此时个人分支与公共分支的 **Commit ID 完全一致**。你无需删除分支，可以直接继续开发。

---

## 3. 严格遵循的“生死线”（三不原则）

为了保证这套线性流程不崩盘，请务必遵守：

*   **不可多人共用私有分支**：
    - 脚本涉及“重写历史”。如果两人共用一个分支，你跑完脚本，另一人的本地基准就直接崩了。**私有分支必须独占。**
*   **不可在公共分支直接修改代码**：
    - 所有的改动必须在 `feat/user-xxx` 产生。公共特性分支（如 `feat/1.0.0`）仅用于接收最终的原子提交。
*   **不可在同步后直接 Pull 远程个人分支**：
    - 运行脚本后，本地历史已变（已美颜）。如果远程曾推过旧历史，Git 会拒绝 `push`。此时**禁止 `pull`**，请直接使用 `push --force-with-lease` 覆盖远程。

---

## 4. QA 与 操作避坑

### **Q1：为什么我们要用 Rebase 而不是以前的 Merge？**
**A**：使用 `merge` 会产生额外的合并节点（即那些“Merge branch...”的信息）。当多人开发时，这些节点会让 Git 图谱变得极其杂乱。使用 `rebase` 可以确保公共分支是一条直线，每个功能点清晰可见，极大提升了排查问题和 Review 代码的效率。

### **Q2：如果使用 rebase 后，在公共分支执行 Squash Merge 会冲突，为什么？**
**A**：这是一个技术细节坑：
*   **场景**：你基于公共分支做了 `rebase`，本地有 `A, B, C` 三个提交。
*   **问题**：如果此时管理员在公共分支上执行 `merge --squash`（在公共分支端压缩），公共分支会产生一个新哈希 `S`。但你的本地还是 `A, B, C`。
*   **后果**：由于哈希 ID 不一致（S ≠ A+B+C），当你下次执行 `rebase` 同步公共分支时，Git 会认为 `A, B, C` 是尚未合入的新改动，尝试再次把它们贴在 `S` 后面。因为内容是一样的，你会陷入无穷无尽的**重复冲突**中。
*   **解决**：`flow` 工具通过在**本地先执行 Soft Reset 压缩**，让两边的哈希 ID 保持完全一致，从而彻底规避冲突。

### **Q3：解决冲突时需要注意什么？**
**A**：解决冲突是唯一的体力活。如果脚本提示冲突，请在编辑器中处理好代码，执行 `git add .` 然后运行 `git rebase --continue`。千万不要在此时执行 `git commit`。

### **Q4：脚本运行报错 `fatal: no upstream configured` 怎么办？**
**A**：这说明你的分支没推过远程，或者没有关联上游。
**结论：** 不影响代码！你的本地压缩和公共分支合并已经成功完成了。这只是脚本无法给你提供“强推建议”的提示而已，忽略即可。

### **Q5：如果操作失误，分支乱了怎么办？**
**A**：**后悔药永远存在**。执行 `git reset --hard ORIG_HEAD`。
这会把你带回运行脚本前的精确时刻，状态会完全恢复，你可以重新来过。

